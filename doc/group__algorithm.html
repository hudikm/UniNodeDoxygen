<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MKL27ZUniversalnode: algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MKL27ZUniversalnode
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__algorithm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">algorithm</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c6f2bcb1008f9074aa7a649611b1d1d"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare &gt; </td></tr>
<tr class="memitem:ga3c6f2bcb1008f9074aa7a649611b1d1d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; TIterator, TIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga3c6f2bcb1008f9074aa7a649611b1d1d">etl::minmax_element</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TCompare <a class="el" href="structetl_1_1compare.html">compare</a>)</td></tr>
<tr class="separator:ga3c6f2bcb1008f9074aa7a649611b1d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c552b4f8c53673b6c5175e482f1a04"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:ga69c552b4f8c53673b6c5175e482f1a04"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; TIterator, TIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga69c552b4f8c53673b6c5175e482f1a04">etl::minmax_element</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>)</td></tr>
<tr class="separator:ga69c552b4f8c53673b6c5175e482f1a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b669e14c867b03129ef8255cba50e64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b669e14c867b03129ef8255cba50e64"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const T &amp;, const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7b669e14c867b03129ef8255cba50e64">etl::minmax</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ga7b669e14c867b03129ef8255cba50e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1a74f0d4b60492e3c726eb41fb5b28"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TCompare &gt; </td></tr>
<tr class="memitem:ga0e1a74f0d4b60492e3c726eb41fb5b28"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const T &amp;, const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0e1a74f0d4b60492e3c726eb41fb5b28">etl::minmax</a> (const T &amp;a, const T &amp;b, TCompare <a class="el" href="structetl_1_1compare.html">compare</a>)</td></tr>
<tr class="separator:ga0e1a74f0d4b60492e3c726eb41fb5b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087c44b697b7bf0199f79c075b0df10f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:ga087c44b697b7bf0199f79c075b0df10f"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga087c44b697b7bf0199f79c075b0df10f">etl::is_sorted_until</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>)</td></tr>
<tr class="separator:ga087c44b697b7bf0199f79c075b0df10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a23368d85895561099ec4fbfef90a43"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare &gt; </td></tr>
<tr class="memitem:ga2a23368d85895561099ec4fbfef90a43"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga2a23368d85895561099ec4fbfef90a43">etl::is_sorted_until</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TCompare <a class="el" href="structetl_1_1compare.html">compare</a>)</td></tr>
<tr class="separator:ga2a23368d85895561099ec4fbfef90a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9646c7c7c670f1f83bcad509f90bf0"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:gacf9646c7c7c670f1f83bcad509f90bf0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gacf9646c7c7c670f1f83bcad509f90bf0">etl::is_sorted</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>)</td></tr>
<tr class="separator:gacf9646c7c7c670f1f83bcad509f90bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab418f05deb2a9d4db264a6d2a24c9da"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare &gt; </td></tr>
<tr class="memitem:gaab418f05deb2a9d4db264a6d2a24c9da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaab418f05deb2a9d4db264a6d2a24c9da">etl::is_sorted</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TCompare <a class="el" href="structetl_1_1compare.html">compare</a>)</td></tr>
<tr class="separator:gaab418f05deb2a9d4db264a6d2a24c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe118fb4198e6cbba850936bdb472cd2"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:gafe118fb4198e6cbba850936bdb472cd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt; etl::is_random_iterator&lt; TInputIterator &gt;::value &amp;&amp;etl::is_random_iterator&lt; TOutputIterator &gt;::value, TOutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gafe118fb4198e6cbba850936bdb472cd2">etl::copy</a> (TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TOutputIterator o_end)</td></tr>
<tr class="separator:gafe118fb4198e6cbba850936bdb472cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3706bd7f9075add7c1cb975f0290f503"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:ga3706bd7f9075add7c1cb975f0290f503"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt; etl::is_random_iterator&lt; TInputIterator &gt;::value, TOutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga3706bd7f9075add7c1cb975f0290f503">etl::copy_n</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin)</td></tr>
<tr class="separator:ga3706bd7f9075add7c1cb975f0290f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8c7743a08d5c274670da5c6e32c465"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:ga6d8c7743a08d5c274670da5c6e32c465"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga6d8c7743a08d5c274670da5c6e32c465">etl::copy_n</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TOutputIterator o_end)</td></tr>
<tr class="separator:ga6d8c7743a08d5c274670da5c6e32c465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a4727874943477611f5d1a48896aac"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize1 , typename TOutputIterator , typename TSize2 &gt; </td></tr>
<tr class="memitem:ga52a4727874943477611f5d1a48896aac"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga52a4727874943477611f5d1a48896aac">etl::copy_n</a> (TInputIterator i_begin, TSize1 n1, TOutputIterator o_begin, TSize2 n2)</td></tr>
<tr class="separator:ga52a4727874943477611f5d1a48896aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715d29eff9f86bc298dc0bf188feb84f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga715d29eff9f86bc298dc0bf188feb84f"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga715d29eff9f86bc298dc0bf188feb84f">etl::copy_if</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TOutputIterator out, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga715d29eff9f86bc298dc0bf188feb84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c565b3a0f90e00ba844918173270b7"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:gab7c565b3a0f90e00ba844918173270b7"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gab7c565b3a0f90e00ba844918173270b7">etl::copy_if</a> (TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TOutputIterator o_end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:gab7c565b3a0f90e00ba844918173270b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09931fd412ffb43680f8762ce0eb99eb"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga09931fd412ffb43680f8762ce0eb99eb"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga09931fd412ffb43680f8762ce0eb99eb">etl::copy_n_if</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga09931fd412ffb43680f8762ce0eb99eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cda71a90079119d5a9a861a9805ff2"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TValue &gt; </td></tr>
<tr class="memitem:ga47cda71a90079119d5a9a861a9805ff2"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga47cda71a90079119d5a9a861a9805ff2">etl::binary_find</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, const TValue &amp;value)</td></tr>
<tr class="separator:ga47cda71a90079119d5a9a861a9805ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1ab79d93dbff5536a491406cc7a97f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TValue , typename TBinaryPredicate , typename TBinaryEquality &gt; </td></tr>
<tr class="memitem:ga7d1ab79d93dbff5536a491406cc7a97f"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7d1ab79d93dbff5536a491406cc7a97f">etl::binary_find</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, const TValue &amp;value, TBinaryPredicate predicate, TBinaryEquality equality)</td></tr>
<tr class="separator:ga7d1ab79d93dbff5536a491406cc7a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8778b98aeab07dd8cb41a93469444c"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:gafe8778b98aeab07dd8cb41a93469444c"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gafe8778b98aeab07dd8cb41a93469444c">etl::find_if_not</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:gafe8778b98aeab07dd8cb41a93469444c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f873a3f1ccac92f205ff7819bed12c"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga61f873a3f1ccac92f205ff7819bed12c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga61f873a3f1ccac92f205ff7819bed12c">etl::all_of</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga61f873a3f1ccac92f205ff7819bed12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ceb2c29a75891da37818cb16e50844"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga68ceb2c29a75891da37818cb16e50844"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga68ceb2c29a75891da37818cb16e50844">etl::any_of</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga68ceb2c29a75891da37818cb16e50844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9d7f6841ac31509eba528eb05394aa"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga1f9d7f6841ac31509eba528eb05394aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1f9d7f6841ac31509eba528eb05394aa">etl::none_of</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga1f9d7f6841ac31509eba528eb05394aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b070e3453360b3e9f86f08e8cd968e"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 &gt; </td></tr>
<tr class="memitem:ga51b070e3453360b3e9f86f08e8cd968e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga51b070e3453360b3e9f86f08e8cd968e">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2)</td></tr>
<tr class="separator:ga51b070e3453360b3e9f86f08e8cd968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefae9d4732ac3d23a5c8a98934f29a73"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 &gt; </td></tr>
<tr class="memitem:gaefae9d4732ac3d23a5c8a98934f29a73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaefae9d4732ac3d23a5c8a98934f29a73">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2, TIterator2 end2)</td></tr>
<tr class="separator:gaefae9d4732ac3d23a5c8a98934f29a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9fd8300a5aa91770e62d38bc1b2f7f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4b9fd8300a5aa91770e62d38bc1b2f7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4b9fd8300a5aa91770e62d38bc1b2f7f">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2, TBinaryPredicate predicate)</td></tr>
<tr class="separator:ga4b9fd8300a5aa91770e62d38bc1b2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4311834725db944b57f1bc6257b6d5"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7c4311834725db944b57f1bc6257b6d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga7c4311834725db944b57f1bc6257b6d5">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2, TIterator2 end2, TBinaryPredicate predicate)</td></tr>
<tr class="separator:ga7c4311834725db944b57f1bc6257b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868f7df6a120febcfb4372c2f656c136"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga868f7df6a120febcfb4372c2f656c136"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga868f7df6a120febcfb4372c2f656c136">etl::is_partitioned</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga868f7df6a120febcfb4372c2f656c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be684913b7cf9b17ec1e8ea30cc2a03"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga0be684913b7cf9b17ec1e8ea30cc2a03"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga0be684913b7cf9b17ec1e8ea30cc2a03">etl::partition_point</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga0be684913b7cf9b17ec1e8ea30cc2a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6a9297b1b106897f3f438f69ee0538"><td class="memTemplParams" colspan="2">template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga4c6a9297b1b106897f3f438f69ee0538"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; TDestinationTrue, TDestinationFalse &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4c6a9297b1b106897f3f438f69ee0538">etl::partition_copy</a> (TSource <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TSource <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TDestinationTrue destination_true, TDestinationFalse destination_false, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga4c6a9297b1b106897f3f438f69ee0538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157238992977b7227d35dc197672d46f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga157238992977b7227d35dc197672d46f"><td class="memTemplItemLeft" align="right" valign="top">TUnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga157238992977b7227d35dc197672d46f">etl::for_each_if</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, const TIterator <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga157238992977b7227d35dc197672d46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef3105161f18db04055950b5ea4c00d"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TSize , typename TUnaryFunction &gt; </td></tr>
<tr class="memitem:gaaef3105161f18db04055950b5ea4c00d"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaaef3105161f18db04055950b5ea4c00d">etl::for_each_n</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TSize n, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>)</td></tr>
<tr class="separator:gaaef3105161f18db04055950b5ea4c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d65d5592b156a616974e580a21584eb"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TSize , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga8d65d5592b156a616974e580a21584eb"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga8d65d5592b156a616974e580a21584eb">etl::for_each_n_if</a> (TIterator <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TSize n, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga8d65d5592b156a616974e580a21584eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb65072e3ce642e24a7193315914f05"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction &gt; </td></tr>
<tr class="memitem:ga4eb65072e3ce642e24a7193315914f05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga4eb65072e3ce642e24a7193315914f05">etl::transform</a> (TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TOutputIterator o_end, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>)</td></tr>
<tr class="separator:ga4eb65072e3ce642e24a7193315914f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec4e1155f60ffa6d94f002ad0d71400"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction &gt; </td></tr>
<tr class="memitem:gaeec4e1155f60ffa6d94f002ad0d71400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt; etl::is_random_iterator&lt; TInputIterator &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaeec4e1155f60ffa6d94f002ad0d71400">etl::transform_n</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>)</td></tr>
<tr class="separator:gaeec4e1155f60ffa6d94f002ad0d71400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1894f2b3cf8722ed3f68762d60489b35"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction &gt; </td></tr>
<tr class="memitem:ga1894f2b3cf8722ed3f68762d60489b35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt; etl::is_random_iterator&lt; TInputIterator1 &gt;::value &amp;&amp;etl::is_random_iterator&lt; TInputIterator2 &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga1894f2b3cf8722ed3f68762d60489b35">etl::transform_n</a> (TInputIterator1 i_begin1, TInputIterator2 i_begin2, TSize n, TOutputIterator o_begin, TBinaryFunction <a class="el" href="classetl_1_1function.html">function</a>)</td></tr>
<tr class="separator:ga1894f2b3cf8722ed3f68762d60489b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152a7bb1e9822dc5b99786011f858442"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga152a7bb1e9822dc5b99786011f858442"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga152a7bb1e9822dc5b99786011f858442">etl::transform_if</a> (TInputIterator i_begin, const TInputIterator i_end, TOutputIterator o_begin, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga152a7bb1e9822dc5b99786011f858442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ee98aa1bc356a7b5788bd60eed5421"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:gae5ee98aa1bc356a7b5788bd60eed5421"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gae5ee98aa1bc356a7b5788bd60eed5421">etl::transform_if</a> (TInputIterator1 i_begin1, const TInputIterator1 i_end1, TInputIterator2 i_begin2, TOutputIterator o_begin, TBinaryFunction <a class="el" href="classetl_1_1function.html">function</a>, TBinaryPredicate predicate)</td></tr>
<tr class="separator:gae5ee98aa1bc356a7b5788bd60eed5421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b89670785401220a2d4f1984cccaf7"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga50b89670785401220a2d4f1984cccaf7"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga50b89670785401220a2d4f1984cccaf7">etl::transform_n_if</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TUnaryFunction <a class="el" href="classetl_1_1function.html">function</a>, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga50b89670785401220a2d4f1984cccaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad25af410cf011b9fe8babedb1272a82b"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:gad25af410cf011b9fe8babedb1272a82b"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gad25af410cf011b9fe8babedb1272a82b">etl::transform_n_if</a> (TInputIterator1 i_begin1, TInputIterator2 i_begin2, TSize n, TOutputIterator o_begin, TBinaryFunction <a class="el" href="classetl_1_1function.html">function</a>, TBinaryPredicate predicate)</td></tr>
<tr class="separator:gad25af410cf011b9fe8babedb1272a82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d6d5db799c42d4e5fdeefce4cb2194"><td class="memTemplParams" colspan="2">template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryFunctionTrue , typename TUnaryFunctionFalse , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:gaa5d6d5db799c42d4e5fdeefce4cb2194"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; TDestinationTrue, TDestinationFalse &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#gaa5d6d5db799c42d4e5fdeefce4cb2194">etl::partition_transform</a> (TSource <a class="el" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f">begin</a>, TSource <a class="el" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34">end</a>, TDestinationTrue destination_true, TDestinationFalse destination_false, TUnaryFunctionTrue function_true, TUnaryFunctionFalse function_false, TUnaryPredicate predicate)</td></tr>
<tr class="separator:gaa5d6d5db799c42d4e5fdeefce4cb2194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c23f81d6ac296db69eb99ff2b1b902"><td class="memTemplParams" colspan="2">template&lt;typename TSource1 , typename TSource2 , typename TDestinationTrue , typename TDestinationFalse , typename TBinaryFunctionTrue , typename TBinaryFunctionFalse , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:ga19c23f81d6ac296db69eb99ff2b1b902"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; TDestinationTrue, TDestinationFalse &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__algorithm.html#ga19c23f81d6ac296db69eb99ff2b1b902">etl::partition_transform</a> (TSource1 begin1, TSource1 end1, TSource2 begin2, TDestinationTrue destination_true, TDestinationFalse destination_false, TBinaryFunctionTrue function_true, TBinaryFunctionFalse function_false, TBinaryPredicate predicate)</td></tr>
<tr class="separator:ga19c23f81d6ac296db69eb99ff2b1b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Reverse engineered algorithms from C++ 0x11 Additional new variants of certain algorithms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga61f873a3f1ccac92f205ff7819bed12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f873a3f1ccac92f205ff7819bed12c">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::all_of </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>all_of</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga61f873a3f1ccac92f205ff7819bed12c_cgraph.png" border="0" usemap="#group__algorithm_ga61f873a3f1ccac92f205ff7819bed12c_cgraph" alt=""/></div>
<map name="group__algorithm_ga61f873a3f1ccac92f205ff7819bed12c_cgraph" id="group__algorithm_ga61f873a3f1ccac92f205ff7819bed12c_cgraph">
<area shape="rect" id="node2" href="group__algorithm.html#gafe8778b98aeab07dd8cb41a93469444c" title="etl::find_if_not" alt="" coords="128,5,232,32"/>
<area shape="rect" id="node4" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="285,56,350,83"/>
<area shape="rect" id="node3" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="280,5,355,32"/>
</map>
</div>

</div>
</div>
<a id="ga68ceb2c29a75891da37818cb16e50844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ceb2c29a75891da37818cb16e50844">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::any_of </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>any_of</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga68ceb2c29a75891da37818cb16e50844_cgraph.png" border="0" usemap="#group__algorithm_ga68ceb2c29a75891da37818cb16e50844_cgraph" alt=""/></div>
<map name="group__algorithm_ga68ceb2c29a75891da37818cb16e50844_cgraph" id="group__algorithm_ga68ceb2c29a75891da37818cb16e50844_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="136,5,201,32"/>
</map>
</div>

</div>
</div>
<a id="ga47cda71a90079119d5a9a861a9805ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47cda71a90079119d5a9a861a9805ff2">&#9670;&nbsp;</a></span>binary_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::binary_find </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>binary_find</p>
<p>Does a binary search and returns an iterator to the value or end if not found. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga47cda71a90079119d5a9a861a9805ff2_cgraph.png" border="0" usemap="#group__algorithm_ga47cda71a90079119d5a9a861a9805ff2_cgraph" alt=""/></div>
<map name="group__algorithm_ga47cda71a90079119d5a9a861a9805ff2_cgraph" id="group__algorithm_ga47cda71a90079119d5a9a861a9805ff2_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="160,5,225,32"/>
</map>
</div>

</div>
</div>
<a id="ga7d1ab79d93dbff5536a491406cc7a97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d1ab79d93dbff5536a491406cc7a97f">&#9670;&nbsp;</a></span>binary_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TValue , typename TBinaryPredicate , typename TBinaryEquality &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::binary_find </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryEquality&#160;</td>
          <td class="paramname"><em>equality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>binary_find</p>
<p>Does a binary search and returns an iterator to the value or end if not found. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga7d1ab79d93dbff5536a491406cc7a97f_cgraph.png" border="0" usemap="#group__algorithm_ga7d1ab79d93dbff5536a491406cc7a97f_cgraph" alt=""/></div>
<map name="group__algorithm_ga7d1ab79d93dbff5536a491406cc7a97f_cgraph" id="group__algorithm_ga7d1ab79d93dbff5536a491406cc7a97f_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="160,5,225,32"/>
</map>
</div>

</div>
</div>
<a id="gafe118fb4198e6cbba850936bdb472cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe118fb4198e6cbba850936bdb472cd2">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt;etl::is_random_iterator&lt;TInputIterator&gt;::value &amp;&amp; etl::is_random_iterator&lt;TOutputIterator&gt;::value, TOutputIterator&gt;::type etl::copy </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy A form of copy where the smallest of the two ranges is used. There is currently no STL equivalent. Specialisation for random access iterators. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_begin</td><td>Beginning of the input range. </td></tr>
    <tr><td class="paramname">i_end</td><td>End of the input range. </td></tr>
    <tr><td class="paramname">o_begin</td><td>Beginning of the output range. </td></tr>
    <tr><td class="paramname">o_end</td><td>End of the output range. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_gafe118fb4198e6cbba850936bdb472cd2_cgraph.png" border="0" usemap="#group__algorithm_gafe118fb4198e6cbba850936bdb472cd2_cgraph" alt=""/></div>
<map name="group__algorithm_gafe118fb4198e6cbba850936bdb472cd2_cgraph" id="group__algorithm_gafe118fb4198e6cbba850936bdb472cd2_cgraph">
<area shape="rect" id="node2" href="namespaceetl.html#gafe118fb4198e6cbba850936bdb472cd2" title="etl::copy" alt="" coords="125,5,197,32"/>
</map>
</div>

</div>
</div>
<a id="ga715d29eff9f86bc298dc0bf188feb84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga715d29eff9f86bc298dc0bf188feb84f">&#9670;&nbsp;</a></span>copy_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_if </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_if</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/copy"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga715d29eff9f86bc298dc0bf188feb84f_cgraph.png" border="0" usemap="#group__algorithm_ga715d29eff9f86bc298dc0bf188feb84f_cgraph" alt=""/></div>
<map name="group__algorithm_ga715d29eff9f86bc298dc0bf188feb84f_cgraph" id="group__algorithm_ga715d29eff9f86bc298dc0bf188feb84f_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="140,5,215,32"/>
</map>
</div>

</div>
</div>
<a id="gab7c565b3a0f90e00ba844918173270b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c565b3a0f90e00ba844918173270b7">&#9670;&nbsp;</a></span>copy_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_if A form of copy_if where it terminates when the first end iterator is reached. There is currently no STL equivelent. </p>

</div>
</div>
<a id="ga3706bd7f9075add7c1cb975f0290f503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3706bd7f9075add7c1cb975f0290f503">&#9670;&nbsp;</a></span>copy_n() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt;etl::is_random_iterator&lt;TInputIterator&gt;::value, TOutputIterator&gt;::type etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n (Random input iterators)</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/copy_n"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga3706bd7f9075add7c1cb975f0290f503_cgraph.png" border="0" usemap="#group__algorithm_ga3706bd7f9075add7c1cb975f0290f503_cgraph" alt=""/></div>
<map name="group__algorithm_ga3706bd7f9075add7c1cb975f0290f503_cgraph" id="group__algorithm_ga3706bd7f9075add7c1cb975f0290f503_cgraph">
<area shape="rect" id="node2" href="namespaceetl.html#gafe118fb4198e6cbba850936bdb472cd2" title="etl::copy" alt="" coords="140,5,212,32"/>
</map>
</div>

</div>
</div>
<a id="ga6d8c7743a08d5c274670da5c6e32c465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8c7743a08d5c274670da5c6e32c465">&#9670;&nbsp;</a></span>copy_n() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n A form of copy_n where the smallest of the two ranges is used. </p>

</div>
</div>
<a id="ga52a4727874943477611f5d1a48896aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a4727874943477611f5d1a48896aac">&#9670;&nbsp;</a></span>copy_n() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize1 , typename TOutputIterator , typename TSize2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize1&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize2&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n A form of copy_n where the smallest of the two ranges is used. </p>

</div>
</div>
<a id="ga09931fd412ffb43680f8762ce0eb99eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09931fd412ffb43680f8762ce0eb99eb">&#9670;&nbsp;</a></span>copy_n_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_n_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n_if Combination of copy_n and copy_if. </p>

</div>
</div>
<a id="gafe8778b98aeab07dd8cb41a93469444c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe8778b98aeab07dd8cb41a93469444c">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::find_if_not </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find_if_not</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/find"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_gafe8778b98aeab07dd8cb41a93469444c_cgraph.png" border="0" usemap="#group__algorithm_gafe8778b98aeab07dd8cb41a93469444c_cgraph" alt=""/></div>
<map name="group__algorithm_gafe8778b98aeab07dd8cb41a93469444c_cgraph" id="group__algorithm_gafe8778b98aeab07dd8cb41a93469444c_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="157,5,232,32"/>
<area shape="rect" id="node3" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="162,56,227,83"/>
</map>
</div>

</div>
</div>
<a id="ga157238992977b7227d35dc197672d46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga157238992977b7227d35dc197672d46f">&#9670;&nbsp;</a></span>for_each_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TUnaryFunction etl::for_each_if </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::for_each but applies a predicate before calling the function. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga157238992977b7227d35dc197672d46f_cgraph.png" border="0" usemap="#group__algorithm_ga157238992977b7227d35dc197672d46f_cgraph" alt=""/></div>
<map name="group__algorithm_ga157238992977b7227d35dc197672d46f_cgraph" id="group__algorithm_ga157238992977b7227d35dc197672d46f_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="161,5,236,32"/>
</map>
</div>

</div>
</div>
<a id="gaaef3105161f18db04055950b5ea4c00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef3105161f18db04055950b5ea4c00d">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TSize , typename TUnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::for_each_n </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::for_each but for 'n' iterations. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_gaaef3105161f18db04055950b5ea4c00d_cgraph.png" border="0" usemap="#group__algorithm_gaaef3105161f18db04055950b5ea4c00d_cgraph" alt=""/></div>
<map name="group__algorithm_gaaef3105161f18db04055950b5ea4c00d_cgraph" id="group__algorithm_gaaef3105161f18db04055950b5ea4c00d_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="161,5,236,32"/>
</map>
</div>

</div>
</div>
<a id="ga8d65d5592b156a616974e580a21584eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d65d5592b156a616974e580a21584eb">&#9670;&nbsp;</a></span>for_each_n_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TSize , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::for_each_n_if </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::for_each but applies a predicate before calling the function, for 'n' iterations </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga8d65d5592b156a616974e580a21584eb_cgraph.png" border="0" usemap="#group__algorithm_ga8d65d5592b156a616974e580a21584eb_cgraph" alt=""/></div>
<map name="group__algorithm_ga8d65d5592b156a616974e580a21584eb_cgraph" id="group__algorithm_ga8d65d5592b156a616974e580a21584eb_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="176,5,251,32"/>
</map>
</div>

</div>
</div>
<a id="ga868f7df6a120febcfb4372c2f656c136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga868f7df6a120febcfb4372c2f656c136">&#9670;&nbsp;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_partitioned</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_partitioned"&gt; </p>

</div>
</div>
<a id="ga51b070e3453360b3e9f86f08e8cd968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b070e3453360b3e9f86f08e8cd968e">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a id="gaefae9d4732ac3d23a5c8a98934f29a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefae9d4732ac3d23a5c8a98934f29a73">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a id="ga4b9fd8300a5aa91770e62d38bc1b2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9fd8300a5aa91770e62d38bc1b2f7f">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a id="ga7c4311834725db944b57f1bc6257b6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c4311834725db944b57f1bc6257b6d5">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a id="gacf9646c7c7c670f1f83bcad509f90bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9646c7c7c670f1f83bcad509f90bf0">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_gacf9646c7c7c670f1f83bcad509f90bf0_cgraph.png" border="0" usemap="#group__algorithm_gacf9646c7c7c670f1f83bcad509f90bf0_cgraph" alt=""/></div>
<map name="group__algorithm_gacf9646c7c7c670f1f83bcad509f90bf0_cgraph" id="group__algorithm_gacf9646c7c7c670f1f83bcad509f90bf0_cgraph">
<area shape="rect" id="node2" href="group__algorithm.html#ga087c44b697b7bf0199f79c075b0df10f" title="etl::is_sorted_until" alt="" coords="151,56,279,83"/>
<area shape="rect" id="node5" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="331,107,397,133"/>
<area shape="rect" id="node3" href="group__container.html#gae0218fbc6b58fad324a64a87c2371d10" title="etl::next" alt="" coords="329,5,399,32"/>
<area shape="rect" id="node4" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="327,56,401,83"/>
</map>
</div>

</div>
</div>
<a id="gaab418f05deb2a9d4db264a6d2a24c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab418f05deb2a9d4db264a6d2a24c9da">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_gaab418f05deb2a9d4db264a6d2a24c9da_cgraph.png" border="0" usemap="#group__algorithm_gaab418f05deb2a9d4db264a6d2a24c9da_cgraph" alt=""/></div>
<map name="group__algorithm_gaab418f05deb2a9d4db264a6d2a24c9da_cgraph" id="group__algorithm_gaab418f05deb2a9d4db264a6d2a24c9da_cgraph">
<area shape="rect" id="node2" href="group__algorithm.html#ga087c44b697b7bf0199f79c075b0df10f" title="etl::is_sorted_until" alt="" coords="151,56,279,83"/>
<area shape="rect" id="node5" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="331,107,397,133"/>
<area shape="rect" id="node3" href="group__container.html#gae0218fbc6b58fad324a64a87c2371d10" title="etl::next" alt="" coords="329,5,399,32"/>
<area shape="rect" id="node4" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="327,56,401,83"/>
</map>
</div>

</div>
</div>
<a id="ga087c44b697b7bf0199f79c075b0df10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga087c44b697b7bf0199f79c075b0df10f">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted_until</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted_until"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga087c44b697b7bf0199f79c075b0df10f_cgraph.png" border="0" usemap="#group__algorithm_ga087c44b697b7bf0199f79c075b0df10f_cgraph" alt=""/></div>
<map name="group__algorithm_ga087c44b697b7bf0199f79c075b0df10f_cgraph" id="group__algorithm_ga087c44b697b7bf0199f79c075b0df10f_cgraph">
<area shape="rect" id="node2" href="group__container.html#gae0218fbc6b58fad324a64a87c2371d10" title="etl::next" alt="" coords="184,5,253,32"/>
<area shape="rect" id="node3" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="181,56,256,83"/>
<area shape="rect" id="node4" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="186,107,251,133"/>
</map>
</div>

</div>
</div>
<a id="ga2a23368d85895561099ec4fbfef90a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a23368d85895561099ec4fbfef90a43">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted_until</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted_until"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga2a23368d85895561099ec4fbfef90a43_cgraph.png" border="0" usemap="#group__algorithm_ga2a23368d85895561099ec4fbfef90a43_cgraph" alt=""/></div>
<map name="group__algorithm_ga2a23368d85895561099ec4fbfef90a43_cgraph" id="group__algorithm_ga2a23368d85895561099ec4fbfef90a43_cgraph">
<area shape="rect" id="node2" href="group__container.html#gae0218fbc6b58fad324a64a87c2371d10" title="etl::next" alt="" coords="184,5,253,32"/>
<area shape="rect" id="node3" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="181,56,256,83"/>
<area shape="rect" id="node4" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="186,107,251,133"/>
</map>
</div>

</div>
</div>
<a id="ga7b669e14c867b03129ef8255cba50e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b669e14c867b03129ef8255cba50e64">&#9670;&nbsp;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const T&amp;, const T&amp;&gt; etl::minmax </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minmax</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/minmax"&gt; </p>

</div>
</div>
<a id="ga0e1a74f0d4b60492e3c726eb41fb5b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e1a74f0d4b60492e3c726eb41fb5b28">&#9670;&nbsp;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const T&amp;, const T&amp;&gt; etl::minmax </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minmax</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/minmax"&gt; </p>

</div>
</div>
<a id="ga3c6f2bcb1008f9074aa7a649611b1d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c6f2bcb1008f9074aa7a649611b1d1d">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;TIterator, TIterator&gt; etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the greatest and the smallest element in the range (begin, end).<br />
 a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga3c6f2bcb1008f9074aa7a649611b1d1d_cgraph.png" border="0" usemap="#group__algorithm_ga3c6f2bcb1008f9074aa7a649611b1d1d_cgraph" alt=""/></div>
<map name="group__algorithm_ga3c6f2bcb1008f9074aa7a649611b1d1d_cgraph" id="group__algorithm_ga3c6f2bcb1008f9074aa7a649611b1d1d_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="196,5,271,32"/>
</map>
</div>

</div>
</div>
<a id="ga69c552b4f8c53673b6c5175e482f1a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69c552b4f8c53673b6c5175e482f1a04">&#9670;&nbsp;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;TIterator, TIterator&gt; etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minmax_element</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga69c552b4f8c53673b6c5175e482f1a04_cgraph.png" border="0" usemap="#group__algorithm_ga69c552b4f8c53673b6c5175e482f1a04_cgraph" alt=""/></div>
<map name="group__algorithm_ga69c552b4f8c53673b6c5175e482f1a04_cgraph" id="group__algorithm_ga69c552b4f8c53673b6c5175e482f1a04_cgraph">
<area shape="rect" id="node2" href="group__algorithm.html#ga3c6f2bcb1008f9074aa7a649611b1d1d" title="etl::minmax_element" alt="" coords="196,5,339,32"/>
<area shape="rect" id="node3" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="387,5,461,32"/>
</map>
</div>

</div>
</div>
<a id="ga1f9d7f6841ac31509eba528eb05394aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f9d7f6841ac31509eba528eb05394aa">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::none_of </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>none_of</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga1f9d7f6841ac31509eba528eb05394aa_cgraph.png" border="0" usemap="#group__algorithm_ga1f9d7f6841ac31509eba528eb05394aa_cgraph" alt=""/></div>
<map name="group__algorithm_ga1f9d7f6841ac31509eba528eb05394aa_cgraph" id="group__algorithm_ga1f9d7f6841ac31509eba528eb05394aa_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="144,5,209,32"/>
</map>
</div>

</div>
</div>
<a id="ga4c6a9297b1b106897f3f438f69ee0538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c6a9297b1b106897f3f438f69ee0538">&#9670;&nbsp;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;TDestinationTrue, TDestinationFalse&gt; etl::partition_copy </td>
          <td>(</td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationTrue&#160;</td>
          <td class="paramname"><em>destination_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationFalse&#160;</td>
          <td class="paramname"><em>destination_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements from the range (begin, end) to two different ranges depending on the value returned by the predicate.<br />
 a href="http://en.cppreference.com/w/cpp/algorithm/partition_copy"&gt; </p>

</div>
</div>
<a id="ga0be684913b7cf9b17ec1e8ea30cc2a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be684913b7cf9b17ec1e8ea30cc2a03">&#9670;&nbsp;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::partition_point </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>partition_point a href="http://en.cppreference.com/w/cpp/algorithm/partition_point"&gt; </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga0be684913b7cf9b17ec1e8ea30cc2a03_cgraph.png" border="0" usemap="#group__algorithm_ga0be684913b7cf9b17ec1e8ea30cc2a03_cgraph" alt=""/></div>
<map name="group__algorithm_ga0be684913b7cf9b17ec1e8ea30cc2a03_cgraph" id="group__algorithm_ga0be684913b7cf9b17ec1e8ea30cc2a03_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="179,5,253,32"/>
</map>
</div>

</div>
</div>
<a id="gaa5d6d5db799c42d4e5fdeefce4cb2194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d6d5db799c42d4e5fdeefce4cb2194">&#9670;&nbsp;</a></span>partition_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryFunctionTrue , typename TUnaryFunctionFalse , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;TDestinationTrue, TDestinationFalse&gt; etl::partition_transform </td>
          <td>(</td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationTrue&#160;</td>
          <td class="paramname"><em>destination_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationFalse&#160;</td>
          <td class="paramname"><em>destination_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunctionTrue&#160;</td>
          <td class="paramname"><em>function_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunctionFalse&#160;</td>
          <td class="paramname"><em>function_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the elements from the range (begin, end) to two different ranges depending on the value returned by the predicate.<br />
 </p>

</div>
</div>
<a id="ga19c23f81d6ac296db69eb99ff2b1b902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19c23f81d6ac296db69eb99ff2b1b902">&#9670;&nbsp;</a></span>partition_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource1 , typename TSource2 , typename TDestinationTrue , typename TDestinationFalse , typename TBinaryFunctionTrue , typename TBinaryFunctionFalse , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;TDestinationTrue, TDestinationFalse&gt; etl::partition_transform </td>
          <td>(</td>
          <td class="paramtype">TSource1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationTrue&#160;</td>
          <td class="paramname"><em>destination_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationFalse&#160;</td>
          <td class="paramname"><em>destination_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunctionTrue&#160;</td>
          <td class="paramname"><em>function_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunctionFalse&#160;</td>
          <td class="paramname"><em>function_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the elements from the ranges (begin1, end1) &amp; (begin2) to two different ranges depending on the value returned by the predicate. </p>

</div>
</div>
<a id="ga4eb65072e3ce642e24a7193315914f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eb65072e3ce642e24a7193315914f05">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void etl::transform </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A form of std::transform where the transform returns when the first range end is reached. There is currently no STL equivalent. </p>

</div>
</div>
<a id="ga152a7bb1e9822dc5b99786011f858442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152a7bb1e9822dc5b99786011f858442">&#9670;&nbsp;</a></span>transform_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::transform but applies a predicate before calling the function. </p>

</div>
</div>
<a id="gae5ee98aa1bc356a7b5788bd60eed5421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5ee98aa1bc356a7b5788bd60eed5421">&#9670;&nbsp;</a></span>transform_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator1&#160;</td>
          <td class="paramname"><em>i_begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputIterator1&#160;</td>
          <td class="paramname"><em>i_end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator2&#160;</td>
          <td class="paramname"><em>i_begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="group__algorithm.html#ga152a7bb1e9822dc5b99786011f858442">etl::transform_if</a> but inputs from two ranges. </p>

</div>
</div>
<a id="gaeec4e1155f60ffa6d94f002ad0d71400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec4e1155f60ffa6d94f002ad0d71400">&#9670;&nbsp;</a></span>transform_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt;etl::is_random_iterator&lt;TInputIterator&gt;::value, void&gt;::type etl::transform_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform 'n' items. Random iterators. There is currently no STL equivalent. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_gaeec4e1155f60ffa6d94f002ad0d71400_cgraph.png" border="0" usemap="#group__algorithm_gaeec4e1155f60ffa6d94f002ad0d71400_cgraph" alt=""/></div>
<map name="group__algorithm_gaeec4e1155f60ffa6d94f002ad0d71400_cgraph" id="group__algorithm_gaeec4e1155f60ffa6d94f002ad0d71400_cgraph">
<area shape="rect" id="node2" href="group__algorithm.html#ga4eb65072e3ce642e24a7193315914f05" title="etl::transform" alt="" coords="167,5,265,32"/>
</map>
</div>

</div>
</div>
<a id="ga1894f2b3cf8722ed3f68762d60489b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1894f2b3cf8722ed3f68762d60489b35">&#9670;&nbsp;</a></span>transform_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structetl_1_1enable__if.html">etl::enable_if</a>&lt;etl::is_random_iterator&lt;TInputIterator1&gt;::value &amp;&amp; etl::is_random_iterator&lt;TInputIterator2&gt;::value, void&gt;::type etl::transform_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator1&#160;</td>
          <td class="paramname"><em>i_begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator2&#160;</td>
          <td class="paramname"><em>i_begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform 'n' items from two ranges. Random iterators. There is currently no STL equivalent. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__algorithm_ga1894f2b3cf8722ed3f68762d60489b35_cgraph.png" border="0" usemap="#group__algorithm_ga1894f2b3cf8722ed3f68762d60489b35_cgraph" alt=""/></div>
<map name="group__algorithm_ga1894f2b3cf8722ed3f68762d60489b35_cgraph" id="group__algorithm_ga1894f2b3cf8722ed3f68762d60489b35_cgraph">
<area shape="rect" id="node2" href="group__algorithm.html#ga4eb65072e3ce642e24a7193315914f05" title="etl::transform" alt="" coords="167,5,265,32"/>
</map>
</div>

</div>
</div>
<a id="ga50b89670785401220a2d4f1984cccaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b89670785401220a2d4f1984cccaf7">&#9670;&nbsp;</a></span>transform_n_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_n_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::transform_if, for 'n' items. </p>

</div>
</div>
<a id="gad25af410cf011b9fe8babedb1272a82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad25af410cf011b9fe8babedb1272a82b">&#9670;&nbsp;</a></span>transform_n_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_n_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator1&#160;</td>
          <td class="paramname"><em>i_begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator2&#160;</td>
          <td class="paramname"><em>i_begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="group__algorithm.html#ga152a7bb1e9822dc5b99786011f858442">etl::transform_if</a> but inputs from two ranges for 'n' items. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
