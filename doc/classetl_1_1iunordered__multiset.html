<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MKL27ZUniversalnode: etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MKL27ZUniversalnode
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classetl_1_1iunordered__multiset.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classetl_1_1iunordered__multiset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__unordered__multiset.html">unordered_multiset</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="unordered__multiset_8h_source.html">unordered_multiset.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset__inherit__graph.png" border="0" usemap="#etl_1_1iunordered__multiset_3_01TKey_00_01THash_00_01TKeyEqual_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="etl_1_1iunordered__multiset_3_01TKey_00_01THash_00_01TKeyEqual_01_4_inherit__map" id="etl_1_1iunordered__multiset_3_01TKey_00_01THash_00_01TKeyEqual_01_4_inherit__map">
<area shape="rect" id="node2" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. " alt="" coords="5,95,201,136"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae01556543a1f003f82f0439e92b10c1"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#aae01556543a1f003f82f0439e92b10c1">begin</a> ()</td></tr>
<tr class="separator:aae01556543a1f003f82f0439e92b10c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31db559cf7a4de9abe8738d77a80d445"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a31db559cf7a4de9abe8738d77a80d445">begin</a> () const</td></tr>
<tr class="separator:a31db559cf7a4de9abe8738d77a80d445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69178bb56a1042ddee9ff47895bf88e4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a69178bb56a1042ddee9ff47895bf88e4">cbegin</a> () const</td></tr>
<tr class="separator:a69178bb56a1042ddee9ff47895bf88e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f08683ed4b5e9c589835fa269625780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a5f08683ed4b5e9c589835fa269625780">begin</a> (size_t i)</td></tr>
<tr class="separator:a5f08683ed4b5e9c589835fa269625780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a2972defe3fb5d912ff2a89e9ff56c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#aa4a2972defe3fb5d912ff2a89e9ff56c">begin</a> (size_t i) const</td></tr>
<tr class="separator:aa4a2972defe3fb5d912ff2a89e9ff56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759ab1a547e50d46b1e3235c06267609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a759ab1a547e50d46b1e3235c06267609">cbegin</a> (size_t i) const</td></tr>
<tr class="separator:a759ab1a547e50d46b1e3235c06267609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d0a0c41f01f4c3e8cf3232985673a"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end</a> ()</td></tr>
<tr class="separator:a3b8d0a0c41f01f4c3e8cf3232985673a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff2d32caf49be7e9e527a347f00dcbb"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a6ff2d32caf49be7e9e527a347f00dcbb">end</a> () const</td></tr>
<tr class="separator:a6ff2d32caf49be7e9e527a347f00dcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3ba37492800d824009886650e18006"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a2c3ba37492800d824009886650e18006">cend</a> () const</td></tr>
<tr class="separator:a2c3ba37492800d824009886650e18006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9757c5e1cda68da39f712368334ee34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ac9757c5e1cda68da39f712368334ee34">end</a> (size_t i)</td></tr>
<tr class="separator:ac9757c5e1cda68da39f712368334ee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82fc8e2155ba74dfca8765ebaa7a5ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ab82fc8e2155ba74dfca8765ebaa7a5ac">end</a> (size_t i) const</td></tr>
<tr class="separator:ab82fc8e2155ba74dfca8765ebaa7a5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43808ccfa73d591707cc459330c276d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ad43808ccfa73d591707cc459330c276d">cend</a> (size_t i) const</td></tr>
<tr class="separator:ad43808ccfa73d591707cc459330c276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e638ad304243634cc6b3329020cfe3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a45e638ad304243634cc6b3329020cfe3">get_bucket_index</a> (key_parameter_t key) const</td></tr>
<tr class="separator:a45e638ad304243634cc6b3329020cfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d890a880de14907f5cfb71cb1fd707"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a71d890a880de14907f5cfb71cb1fd707">bucket_size</a> (key_parameter_t key) const</td></tr>
<tr class="separator:a71d890a880de14907f5cfb71cb1fd707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad330028a6f4a596d1d1d9f31e9a6c7b6"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ad330028a6f4a596d1d1d9f31e9a6c7b6">max_bucket_count</a> () const</td></tr>
<tr class="separator:ad330028a6f4a596d1d1d9f31e9a6c7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addde0bc6373557db3ab456b48c0fa7db"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#addde0bc6373557db3ab456b48c0fa7db">bucket_count</a> () const</td></tr>
<tr class="separator:addde0bc6373557db3ab456b48c0fa7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1777b3b94c358236e7e04a39abf2f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:a61c1777b3b94c358236e7e04a39abf2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a61c1777b3b94c358236e7e04a39abf2f">assign</a> (TIterator first_, TIterator last_)</td></tr>
<tr class="separator:a61c1777b3b94c358236e7e04a39abf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4096dfb43a2ee13cce40b4912257c6fa"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a4096dfb43a2ee13cce40b4912257c6fa">insert</a> (const value_type &amp;key)</td></tr>
<tr class="separator:a4096dfb43a2ee13cce40b4912257c6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcafd38dbdeea4b99aa7bfaef84c3532"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#afcafd38dbdeea4b99aa7bfaef84c3532">insert</a> (const_iterator position, const value_type &amp;key)</td></tr>
<tr class="separator:afcafd38dbdeea4b99aa7bfaef84c3532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b63de22e0dc58d1f442405fbbc4f56e"><td class="memTemplParams" colspan="2">template&lt;class TIterator &gt; </td></tr>
<tr class="memitem:a7b63de22e0dc58d1f442405fbbc4f56e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a7b63de22e0dc58d1f442405fbbc4f56e">insert</a> (TIterator first_, TIterator last_)</td></tr>
<tr class="separator:a7b63de22e0dc58d1f442405fbbc4f56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331b96b67b5ea4e1809bba0916848e67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a331b96b67b5ea4e1809bba0916848e67">erase</a> (key_parameter_t key)</td></tr>
<tr class="separator:a331b96b67b5ea4e1809bba0916848e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be01b721ae8487fdb1174b5458c20a"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ab3be01b721ae8487fdb1174b5458c20a">erase</a> (const_iterator ielement)</td></tr>
<tr class="separator:ab3be01b721ae8487fdb1174b5458c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92504ab3bd354bc1643289b9716638d3"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a92504ab3bd354bc1643289b9716638d3">erase</a> (const_iterator first_, const_iterator last_)</td></tr>
<tr class="separator:a92504ab3bd354bc1643289b9716638d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8097efee0bce110362757fa22b7ea22c"><td class="memItemLeft" align="right" valign="top"><a id="a8097efee0bce110362757fa22b7ea22c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a8097efee0bce110362757fa22b7ea22c">clear</a> ()</td></tr>
<tr class="memdesc:a8097efee0bce110362757fa22b7ea22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br /></td></tr>
<tr class="separator:a8097efee0bce110362757fa22b7ea22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c7de738f2aa8d53f9e481dd33560be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ae2c7de738f2aa8d53f9e481dd33560be">count</a> (key_parameter_t key) const</td></tr>
<tr class="separator:ae2c7de738f2aa8d53f9e481dd33560be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e59844d174e1a9eed6af9c008b9e483"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a9e59844d174e1a9eed6af9c008b9e483">find</a> (key_parameter_t key)</td></tr>
<tr class="separator:a9e59844d174e1a9eed6af9c008b9e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c71ad68082e7f50fd83b1caf5075dbd"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a5c71ad68082e7f50fd83b1caf5075dbd">find</a> (key_parameter_t key) const</td></tr>
<tr class="separator:a5c71ad68082e7f50fd83b1caf5075dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812b37ad93ec70e5789ea1f45daf6cde"><td class="memItemLeft" align="right" valign="top">std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a812b37ad93ec70e5789ea1f45daf6cde">equal_range</a> (key_parameter_t key)</td></tr>
<tr class="separator:a812b37ad93ec70e5789ea1f45daf6cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3d574238c52c9541a6b9ef82c99317"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const_iterator, const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#aea3d574238c52c9541a6b9ef82c99317">equal_range</a> (key_parameter_t key) const</td></tr>
<tr class="separator:aea3d574238c52c9541a6b9ef82c99317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f94ef6ae8cfa17b018472e54c2442"><td class="memItemLeft" align="right" valign="top"><a id="ad59f94ef6ae8cfa17b018472e54c2442"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ad59f94ef6ae8cfa17b018472e54c2442">size</a> () const</td></tr>
<tr class="memdesc:ad59f94ef6ae8cfa17b018472e54c2442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br /></td></tr>
<tr class="separator:ad59f94ef6ae8cfa17b018472e54c2442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3b131c041bf5bdef5767cd595607f8"><td class="memItemLeft" align="right" valign="top"><a id="a3e3b131c041bf5bdef5767cd595607f8"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a3e3b131c041bf5bdef5767cd595607f8">max_size</a> () const</td></tr>
<tr class="memdesc:a3e3b131c041bf5bdef5767cd595607f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum possible size of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br /></td></tr>
<tr class="separator:a3e3b131c041bf5bdef5767cd595607f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90843105b8ca6ed72b562625fbd2d5"><td class="memItemLeft" align="right" valign="top"><a id="afe90843105b8ca6ed72b562625fbd2d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#afe90843105b8ca6ed72b562625fbd2d5">empty</a> () const</td></tr>
<tr class="memdesc:afe90843105b8ca6ed72b562625fbd2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is empty. <br /></td></tr>
<tr class="separator:afe90843105b8ca6ed72b562625fbd2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bb26aa7667d0d2172602ce14cc769d"><td class="memItemLeft" align="right" valign="top"><a id="ae5bb26aa7667d0d2172602ce14cc769d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ae5bb26aa7667d0d2172602ce14cc769d">full</a> () const</td></tr>
<tr class="memdesc:ae5bb26aa7667d0d2172602ce14cc769d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is full. <br /></td></tr>
<tr class="separator:ae5bb26aa7667d0d2172602ce14cc769d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcf9299e3d081fad893489140a7db35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a0bcf9299e3d081fad893489140a7db35">available</a> () const</td></tr>
<tr class="separator:a0bcf9299e3d081fad893489140a7db35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec87e1da71b968a17cee2c290ebe9af1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#aec87e1da71b968a17cee2c290ebe9af1">load_factor</a> () const</td></tr>
<tr class="separator:aec87e1da71b968a17cee2c290ebe9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbc98115ece6f3e4fe63cd465331a28"><td class="memItemLeft" align="right" valign="top">hasher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#adcbc98115ece6f3e4fe63cd465331a28">hash_function</a> () const</td></tr>
<tr class="separator:adcbc98115ece6f3e4fe63cd465331a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ea62c36af19aef8172c4bdd329ea27"><td class="memItemLeft" align="right" valign="top">key_equal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#ac0ea62c36af19aef8172c4bdd329ea27">key_eq</a> () const</td></tr>
<tr class="separator:ac0ea62c36af19aef8172c4bdd329ea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee48d995aceaf6a10aa1813b3134e48"><td class="memItemLeft" align="right" valign="top"><a id="a9ee48d995aceaf6a10aa1813b3134e48"></a>
<a class="el" href="classetl_1_1iunordered__multiset.html">iunordered_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a9ee48d995aceaf6a10aa1813b3134e48">operator=</a> (const <a class="el" href="classetl_1_1iunordered__multiset.html">iunordered_multiset</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9ee48d995aceaf6a10aa1813b3134e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a9ee48d995aceaf6a10aa1813b3134e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a01269ea4ceec927ef193db691e0574f3"><td class="memItemLeft" align="right" valign="top"><a id="a01269ea4ceec927ef193db691e0574f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a01269ea4ceec927ef193db691e0574f3">iunordered_multiset</a> (pool_t &amp;node_pool_, <a class="el" href="classetl_1_1intrusive__forward__list.html">bucket_t</a> *pbuckets_, size_t number_of_buckets_)</td></tr>
<tr class="memdesc:a01269ea4ceec927ef193db691e0574f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a01269ea4ceec927ef193db691e0574f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b71336813276ecff6b35cd9f0ae7c98"><td class="memItemLeft" align="right" valign="top"><a id="a3b71336813276ecff6b35cd9f0ae7c98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a3b71336813276ecff6b35cd9f0ae7c98">initialise</a> ()</td></tr>
<tr class="memdesc:a3b71336813276ecff6b35cd9f0ae7c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br /></td></tr>
<tr class="separator:a3b71336813276ecff6b35cd9f0ae7c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0383417190b92d787b91c9623a3116b0"><td class="memItemLeft" align="right" valign="top"><a id="a0383417190b92d787b91c9623a3116b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classetl_1_1iunordered__multiset.html#a0383417190b92d787b91c9623a3116b0">~iunordered_multiset</a> ()</td></tr>
<tr class="memdesc:a0383417190b92d787b91c9623a3116b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a0383417190b92d787b91c9623a3116b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt;<br />
class etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt;</h3>

<p>The base class for specifically sized <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. Can be used as a reference type for all <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> containing a specific type. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a61c1777b3b94c358236e7e04a39abf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c1777b3b94c358236e7e04a39abf2f">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>last_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns values to the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> does not have enough free space. If asserts or exceptions are enabled, emits <a class="el" href="classetl_1_1unordered__multiset__iterator.html">unordered_multiset_iterator</a> if the iterators are reversed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element + 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bcf9299e3d081fad893489140a7db35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcf9299e3d081fad893489140a7db35">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the remaining capacity. </p><dl class="section return"><dt>Returns</dt><dd>The remaining capacity. </dd></dl>

</div>
</div>
<a id="aae01556543a1f003f82f0439e92b10c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae01556543a1f003f82f0439e92b10c1">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p><dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a id="a31db559cf7a4de9abe8738d77a80d445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31db559cf7a4de9abe8738d77a80d445">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a id="a5f08683ed4b5e9c589835fa269625780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f08683ed4b5e9c589835fa269625780">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a> <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p><dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a id="aa4a2972defe3fb5d912ff2a89e9ff56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a2972defe3fb5d912ff2a89e9ff56c">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a id="addde0bc6373557db3ab456b48c0fa7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addde0bc6373557db3ab456b48c0fa7db">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of the buckets the container holds. </p><dl class="section return"><dt>Returns</dt><dd>The number of the buckets the container holds. </dd></dl>

</div>
</div>
<a id="a71d890a880de14907f5cfb71cb1fd707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d890a880de14907f5cfb71cb1fd707">&#9670;&nbsp;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the bucket key. </p><dl class="section return"><dt>Returns</dt><dd>The bucket size of the bucket key. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_a71d890a880de14907f5cfb71cb1fd707_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_a71d890a880de14907f5cfb71cb1fd707_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_a71d890a880de14907f5cfb71cb1fd707_cgraph" id="classetl_1_1iunordered__multiset_a71d890a880de14907f5cfb71cb1fd707_cgraph">
<area shape="rect" id="node2" href="group__container.html#gaa49c1627c231bf2777a22f166ec94d1f" title="etl::begin" alt="" coords="211,5,285,32"/>
<area shape="rect" id="node3" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="215,56,281,83"/>
</map>
</div>

</div>
</div>
<a id="a69178bb56a1042ddee9ff47895bf88e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69178bb56a1042ddee9ff47895bf88e4">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a id="a759ab1a547e50d46b1e3235c06267609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759ab1a547e50d46b1e3235c06267609">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a id="a2c3ba37492800d824009886650e18006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3ba37492800d824009886650e18006">&#9670;&nbsp;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a id="ad43808ccfa73d591707cc459330c276d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43808ccfa73d591707cc459330c276d">&#9670;&nbsp;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a id="ae2c7de738f2aa8d53f9e481dd33560be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7de738f2aa8d53f9e481dd33560be">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::count </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts an element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the key exists, otherwise 0. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_ae2c7de738f2aa8d53f9e481dd33560be_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_ae2c7de738f2aa8d53f9e481dd33560be_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_ae2c7de738f2aa8d53f9e481dd33560be_cgraph" id="classetl_1_1iunordered__multiset_ae2c7de738f2aa8d53f9e481dd33560be_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="211,13,276,39"/>
</map>
</div>

</div>
</div>
<a id="a3b8d0a0c41f01f4c3e8cf3232985673a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8d0a0c41f01f4c3e8cf3232985673a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p><dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a id="a6ff2d32caf49be7e9e527a347f00dcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff2d32caf49be7e9e527a347f00dcbb">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a id="ac9757c5e1cda68da39f712368334ee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9757c5e1cda68da39f712368334ee34">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a> <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p><dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a id="ab82fc8e2155ba74dfca8765ebaa7a5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82fc8e2155ba74dfca8765ebaa7a5ac">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p><dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a id="a812b37ad93ec70e5789ea1f45daf6cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812b37ad93ec70e5789ea1f45daf6cde">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, iterator&gt; <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range containing all elements with key key in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pair to the range of elements if the key exists, otherwise <a class="el" href="classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_a812b37ad93ec70e5789ea1f45daf6cde_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_a812b37ad93ec70e5789ea1f45daf6cde_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_a812b37ad93ec70e5789ea1f45daf6cde_cgraph" id="classetl_1_1iunordered__multiset_a812b37ad93ec70e5789ea1f45daf6cde_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="211,13,276,39"/>
</map>
</div>

</div>
</div>
<a id="aea3d574238c52c9541a6b9ef82c99317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3d574238c52c9541a6b9ef82c99317">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range containing all elements with key key in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator pair to the range of elements if the key exists, otherwise <a class="el" href="classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_aea3d574238c52c9541a6b9ef82c99317_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_aea3d574238c52c9541a6b9ef82c99317_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_aea3d574238c52c9541a6b9ef82c99317_cgraph" id="classetl_1_1iunordered__multiset_aea3d574238c52c9541a6b9ef82c99317_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="211,13,276,39"/>
</map>
</div>

</div>
</div>
<a id="a331b96b67b5ea4e1809bba0916848e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331b96b67b5ea4e1809bba0916848e67">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases an element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_a331b96b67b5ea4e1809bba0916848e67_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_a331b96b67b5ea4e1809bba0916848e67_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_a331b96b67b5ea4e1809bba0916848e67_cgraph" id="classetl_1_1iunordered__multiset_a331b96b67b5ea4e1809bba0916848e67_cgraph">
<area shape="rect" id="node2" href="classetl_1_1intrusive__forward__list.html#aadfecc542da4eda698be1ec0ad461566" title="Gets before the beginning of the intrusive_forward_list. " alt="" coords="211,5,353,47"/>
<area shape="rect" id="node3" href="classetl_1_1intrusive__forward__list.html#ae27fbc133af8c584699b0604cfd07f4b" title="Gets the beginning of the intrusive_forward_list. " alt="" coords="211,71,353,112"/>
<area shape="rect" id="node4" href="classetl_1_1intrusive__forward__list.html#aaa13ae68be9d3f06e80c12a455d7332c" title="Gets the end of the intrusive_forward_list. " alt="" coords="211,136,353,177"/>
<area shape="rect" id="node5" href="classetl_1_1intrusive__forward__list.html#a87e08c5fc9785c47f8d1996b2ae2b12d" title="Erases the value at the specified position. " alt="" coords="211,201,353,243"/>
</map>
</div>

</div>
</div>
<a id="ab3be01b721ae8487fdb1174b5458c20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3be01b721ae8487fdb1174b5458c20a">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>ielement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases an element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ielement</td><td>Iterator to the element. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_ab3be01b721ae8487fdb1174b5458c20a_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_ab3be01b721ae8487fdb1174b5458c20a_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_ab3be01b721ae8487fdb1174b5458c20a_cgraph" id="classetl_1_1iunordered__multiset_ab3be01b721ae8487fdb1174b5458c20a_cgraph">
<area shape="rect" id="node2" href="classetl_1_1intrusive__forward__list.html#aadfecc542da4eda698be1ec0ad461566" title="Gets before the beginning of the intrusive_forward_list. " alt="" coords="211,5,353,47"/>
<area shape="rect" id="node3" href="classetl_1_1intrusive__forward__list.html#a87e08c5fc9785c47f8d1996b2ae2b12d" title="Erases the value at the specified position. " alt="" coords="211,71,353,112"/>
</map>
</div>

</div>
</div>
<a id="a92504ab3bd354bc1643289b9716638d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92504ab3bd354bc1643289b9716638d3">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases a range of elements. The range includes all the elements between first and last, including the element pointed by first, but not the one pointed to by last. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e59844d174e1a9eed6af9c008b9e483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e59844d174e1a9eed6af9c008b9e483">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::find </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element if the key exists, otherwise <a class="el" href="classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_a9e59844d174e1a9eed6af9c008b9e483_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_a9e59844d174e1a9eed6af9c008b9e483_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_a9e59844d174e1a9eed6af9c008b9e483_cgraph" id="classetl_1_1iunordered__multiset_a9e59844d174e1a9eed6af9c008b9e483_cgraph">
<area shape="rect" id="node2" href="classetl_1_1intrusive__forward__list__base.html#a52c2e88e380ec2ba1abe170c60cc2482" title="Returns true if the list has no elements. " alt="" coords="211,5,353,47"/>
<area shape="rect" id="node3" href="classetl_1_1intrusive__forward__list.html#ae27fbc133af8c584699b0604cfd07f4b" title="Gets the beginning of the intrusive_forward_list. " alt="" coords="211,71,353,112"/>
<area shape="rect" id="node4" href="classetl_1_1intrusive__forward__list.html#aaa13ae68be9d3f06e80c12a455d7332c" title="Gets the end of the intrusive_forward_list. " alt="" coords="211,136,353,177"/>
<area shape="rect" id="node5" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="249,202,315,229"/>
</map>
</div>

</div>
</div>
<a id="a5c71ad68082e7f50fd83b1caf5075dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c71ad68082e7f50fd83b1caf5075dbd">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::find </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element if the key exists, otherwise <a class="el" href="classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_a5c71ad68082e7f50fd83b1caf5075dbd_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_a5c71ad68082e7f50fd83b1caf5075dbd_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_a5c71ad68082e7f50fd83b1caf5075dbd_cgraph" id="classetl_1_1iunordered__multiset_a5c71ad68082e7f50fd83b1caf5075dbd_cgraph">
<area shape="rect" id="node2" href="classetl_1_1intrusive__forward__list__base.html#a52c2e88e380ec2ba1abe170c60cc2482" title="Returns true if the list has no elements. " alt="" coords="211,5,353,47"/>
<area shape="rect" id="node3" href="classetl_1_1intrusive__forward__list.html#ae27fbc133af8c584699b0604cfd07f4b" title="Gets the beginning of the intrusive_forward_list. " alt="" coords="211,71,353,112"/>
<area shape="rect" id="node4" href="classetl_1_1intrusive__forward__list.html#aaa13ae68be9d3f06e80c12a455d7332c" title="Gets the end of the intrusive_forward_list. " alt="" coords="211,136,353,177"/>
<area shape="rect" id="node5" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="249,202,315,229"/>
</map>
</div>

</div>
</div>
<a id="a45e638ad304243634cc6b3329020cfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e638ad304243634cc6b3329020cfe3">&#9670;&nbsp;</a></span>get_bucket_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::get_bucket_index </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bucket index for the key. </p><dl class="section return"><dt>Returns</dt><dd>The bucket index for the key. </dd></dl>

</div>
</div>
<a id="adcbc98115ece6f3e4fe63cd465331a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbc98115ece6f3e4fe63cd465331a28">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hasher <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that hashes the keys. </p><dl class="section return"><dt>Returns</dt><dd>The function that hashes the keys.. </dd></dl>

</div>
</div>
<a id="a4096dfb43a2ee13cce40b4912257c6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4096dfb43a2ee13cce40b4912257c6fa">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;iterator, bool&gt; <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a value to the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is already full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classetl_1_1iunordered__multiset_a4096dfb43a2ee13cce40b4912257c6fa_cgraph.png" border="0" usemap="#classetl_1_1iunordered__multiset_a4096dfb43a2ee13cce40b4912257c6fa_cgraph" alt=""/></div>
<map name="classetl_1_1iunordered__multiset_a4096dfb43a2ee13cce40b4912257c6fa_cgraph" id="classetl_1_1iunordered__multiset_a4096dfb43a2ee13cce40b4912257c6fa_cgraph">
<area shape="rect" id="node2" href="group__container.html#gafa83f3ea1433dccd467186ab3f677b34" title="etl::end" alt="" coords="211,13,276,39"/>
</map>
</div>

</div>
</div>
<a id="afcafd38dbdeea4b99aa7bfaef84c3532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcafd38dbdeea4b99aa7bfaef84c3532">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a value to the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is already full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position to insert at. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b63de22e0dc58d1f442405fbbc4f56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b63de22e0dc58d1f442405fbbc4f56e">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<div class="memtemplate">
template&lt;class TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>last_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a range of values to the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> does not have enough free space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position to insert at. </td></tr>
    <tr><td class="paramname">first</td><td>The first element to add. </td></tr>
    <tr><td class="paramname">last</td><td>The last + 1 element to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0ea62c36af19aef8172c4bdd329ea27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ea62c36af19aef8172c4bdd329ea27">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">key_equal <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that compares the keys. </p><dl class="section return"><dt>Returns</dt><dd>The function that compares the keys.. </dd></dl>

</div>
</div>
<a id="aec87e1da71b968a17cee2c290ebe9af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec87e1da71b968a17cee2c290ebe9af1">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the load factor = size / bucket_count. </p><dl class="section return"><dt>Returns</dt><dd>The load factor = size / bucket_count. </dd></dl>

</div>
</div>
<a id="ad330028a6f4a596d1d1d9f31e9a6c7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad330028a6f4a596d1d1d9f31e9a6c7b6">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of the buckets the container can hold. </p><dl class="section return"><dt>Returns</dt><dd>The maximum number of the buckets the container can hold. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>etl/<a class="el" href="unordered__multiset_8h_source.html">unordered_multiset.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="classetl_1_1iunordered__multiset.html">iunordered_multiset</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
